<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0034)http://fedoruk.comcor.ru/java.html -->
<HTML><HEAD><TITLE>Java после C/C++</TITLE>
<META http-equiv=Content-Type content="text/html; charset=koi8-r">
<META content="MSHTML 6.00.2900.2180" name=GENERATOR></HEAD>
<BODY>
<CENTER>
<H3>Московский Государственный Технический Университет</H3></CENTER>
<CENTER><B>имени Н.Э.Баумана</B></CENTER>
<CENTER>
<H3>Кафедра САПР</H3></CENTER>
<CENTER>
<H2>
<HR width="100%">
Java после C/C++</H2></CENTER>
<DIV align=right><B>Федорук В.Г.</B></DIV>
<CENTER>Содержание </CENTER>
<UL>
  <LI><A href="http://fedoruk.comcor.ru/java.html#properties">Свойства языка 
  Java</A> 
  <LI><A href="http://fedoruk.comcor.ru/java.html#diff_c">Отличия Java от C</A> 
  <LI><A href="http://fedoruk.comcor.ru/java.html#diff_c++">Классы и объекты в 
  Java</A> </LI></UL>
<CENTER>
<H2><A name=#properties>Свойства языка Java</A> </H2></CENTER>
<P>Язык программирования Java создан в 1995 г. фирмой Sun Microsystems (Java - 
название любимого сорта кофе разработчиков). Основная цель - создать несложный 
язык для программирования в Internet. Отсюда вытекают его главные свойства. </P>
<P><I>Примечание.</I> Далее будет показано, что Java - весьма привлекательный 
язык для для новоиспеченных программистов-"чайников". Профессиональных 
программистов (a-la Д. Кнут) в нем могут привлечь в основном средства создания 
системного-независимого графического интерфейса пользователя. 
</P><B>Объектно-ориентированный</B> 
<P>Основные элементы языка - <I>объекты</I>, являющиеся <I>экземплярами</I> 
классов. <I>Класс</I> - совокупность <I>данных</I> и <I>методов</I> (функций, 
процедур) обработки этих данных. Классы организованы в иерархию в виде "строго" 
дерева (множественного наследования в духе C++ в Java нет). Корнем иерархии 
служит класс Object. <I>Необъекты</I> в Java - это только простые числовые, 
символьные и булевы типы. Любая программа в Java - это класс (например, с 
методом main для приложения). Единицей компиляции и выполнения также является 
класс. </P>
<P>Классы в Java объединены в <I>пакеты</I> (package), облегчающие разработку 
программ той или иной функциональности. Обычно в пакет попадают классы из разных 
ветвей дерева иерархии классов. Примеры пакетов: java.io - классы ввода-вывода; 
java.awt - классы компонентов графического интерфейса пользователя; java.net - 
классы для организации сетевого взаимодействия. </P><B>Интерпретируемый</B> 
<P>Исходный текст программы (класса) обрабатывается <I>компилятором</I> Java 
(javac), однако, в отличие от традиционных компиляторов (таких, как C и C++), он 
создает не объектный файл (например, формата ELF), содержащий машинные команды, 
а файл с последовательностью <I>байт-кодов</I>. На этапе выполнения программы 
байт-коды считываются и <I>интерпретируются</I> виртуальной Java-машиной (JVM - 
Java Virtual Machine). Таким образом, откомпилированная Java-программа может 
быть выполнена на тех вычислительных архитектурах, для которых реализована JVM 
(в настоящее время спектр таких вычислительных средств - от супер-ЭВМ до 
мобильных телефонов). </P>
<P><I>Примечание.</I> Ни что не запрещает JVM для выполнения Java-программы 
<I>откомпилировать</I> ее байт-коды в машинные команды. </P><B>Переносимый</B> 
<P>Огромный вклад в переносимость Java-программ вносит независимость 
откомпилированных байт-кодов от архитектуры вычислительных средств исполнения. 
Но Java идет дальше, обеспечивая отсутствие зависящих от реализации аспектов в 
спецификации языка. Например, как мы знаем, в С (и C++) перменная типа int может 
иметь размер 2, 4 или 8 байт, переменная типа char может быть без- или знаковой, 
в Java же явно и строго определены размеры и свойства каждого простого типа 
данных. Также существенно, что Java обеспечивает единые средства создания 
графического интерфейса пользователя для разных операционных сред (UNIX, 
Windows, MacOS), проповедующих совершенно противоположные идеологии графического 
интерфейса. </P><B>Динамический</B> 
<P>При подготовке и запуске Java-программ на выполнение отсутствует традиционный 
этап <I>компоновки</I> - объединения кода программы с кодом всех используемых ее 
функций ( в C) и классов (в C++). Интепретатор Java (JVM) загрузку необходимых 
классов осуществляет динамически в момент возникновения потребности в них. Более 
того, в Java существует возможность (пакет java.lang.reflect) динамически 
получать исчерпывающую информацию о любом классе (переменные, конструкторы, 
методы). </P>
<P><I>Примечание.</I> Необходимо, правда, отметить, что динамическое связывание 
- это, в настоящее время, стандарный атрибут любой вычислительной среды 
(вспомним ".so" в UNIX и ".dll" в Windows). </P><B>Распределенный</B> 
<P>Во-первых, Java поддерживает сетевой обмен, используя канонический 
<I>socket</I>-интерфейс. </P>
<P>Во-вторых, Java (через пакет java.net) обеспечивает средства высокоуровневого 
доступа по сети, позволяющие, например, читать удаленный файл так же просто, как 
и файл локальный. </P>
<P>В-третьих (что наиболее интересно), средства динамической загрузки классов, 
позволяют JVM загружать и запускать на выполнение методы удаленных объектов. 
Достигается такая возможность использованием средств RMI (Remote Method 
Invocation), собранных в пакеты java.rmi.*. </P><B>Простой</B> 
<P>Java - простой язык, поскольку он легок для изучения, что объясняется двумя 
факторами: небольшое количество языковых конструкций ( что важно для 
"чайников"), "похожесть" на самые употребляемые языки C и C++ (что важно для 
миграции на Java). Например, в Java нет конструкций struct и union (из C), т.к. 
он объектно-ориентированный язык, но в нем нет множественного наследования и 
перегрузки операций (из C++). Но самое главное - в Java нет указателей! 
</P><B>Устойчивый</B> 
<P>Разработчики языка Java ставили перед собой задачу повысить надежность 
(устойчивость) разрабатываемых с его помощью программ. Для этого они, в 
частности, строго типизировали язык и предусмотрели средства контроля выполнения 
ряда действий (например, допустимость приведения типов данных). Исключение из 
языка указателей и арифметических операций над ними устранило и целый класс 
ошибок, связанный с неправильных их применением. </P>
<P>Автоматический <I>сбор мусора</I> (garbage collection) предотвращает "утечки" 
памяти. Повышению устойчивости программ на Java способствует также использование 
конструкции try/catch/finally, позволяющей сгруппировать код, ответственный за 
обработку <I>исключений</I> (exceptions), в том числе ошибок выполнения, в одном 
месте программы. </P><B>Безопасный</B> 
<P>Обеспечение высокого уровня безопасности программ - основное требование к 
языку сетевого программирования, используемому для их разработки. Java реализует 
несколько уровней защиты от преднамеренного или неумышленного нарушения работы 
целевой вычислительной системы. </P>
<P>Первый уровень - это исключение возможности прямого доступа к памяти в 
программах на Java через указатели. </P>
<P>Второй уровень - проверка на корректность байт-кода, загружаемого в 
виртуальную Java-машину. </P>
<P>Третий уровень - реализация модели "песочницы" (sandbox). Согласно этой 
модели программы, не заслуживающие доверия (например, загруженные по сети 
апплеты) помещаются в "песочницу", где они могут "играть", не нанося ущерба 
среде Java и локальной операционной системе. Очевидным примером ограничений 
"песочницы" служит запрет доступа к локальной файловой системе. Подобные 
ограничения накладываются классом SecurityManager. </P>
<P>С другой стороны, Java-программы (те же апплеты) могут снабжаться 
электронными подписями доверенных лиц и организаций, что позволяет полностью или 
частично снимать ограничения на их выполнение. </P>
<P>Надо также отметить, что средств защиты от DOS-атак (отказ в обслуживании) в 
Java нет. </P><B>Эффективный</B> 
<P>Конечно же, программы на Java, как на интерпретируемом языке, не могут быть 
столь экономичны, как на компилируемых C и C++. Однако компиляция в байт-коды 
делает Java-программы более быстрыми, чем программы на других интерпретируемых 
языках (sh/bash, csh, Tcl и даже Perl и PHP). Более того, современные JVM 
обладают способностью компилировать байт-коды в машинные команды целевой ЭВМ "на 
лету", а это уже делает скорость выполнения Java-программ сопоставимой со 
скоростью программ, написанных на C и C++. Кроме этого Java обеспечивает 
возможность для критических участков программы создавать код на C или C++. </P>
<P>С другой стороны, Java - язык для создания сетевых интерактивных программ и 
апплетов (в которых львиная доля времени уходит на ожидание ответов по сети или 
реакции пользователя). Здесь производительность JVM вполне адекватна решаемой 
задаче. </P><B>Многопотоковый</B> 
<P>При программировании на C и C++ многопоточность задачи обеспечивается 
средствами целевой ОС и библиотекой соответствующих системных системных вызовов 
и функций. В Java поддержка многопоточности реализована языковыми средствами. 
Так, в пакете java.lang содержится класс Thread, обеспечивающий методы запуска и 
завершения потоков. Имеется также конструкция synchronized, позволяющая отмечать 
участки программы и целык методы, которые должны одновременно выполняться только 
одним потоком. </P>
<P><I>Примечание</I>. Создание якобы параллельно выполняющихся потоков - 
тривиальная задача в любой среде программирования. Проблема - заставить их 
<I>реально</I> выполняться <I>паралллельно</I> в многопроцессорной системе. а уж 
куда более сложная проблема - эффективно их засинхронизоравать (тут от 
взаимоисключающих блокировок, семафоров и т. п. никуда не деться). </P>
<CENTER>
<H2><A name=diff_c>Отличия Java от C</A> </H2></CENTER>
<P>Естественно, что фундаментальное отличие в том, что Java - это 
объектно-ориентированный язык. Но ОО-свойства Java обсудим позже, сравнивая его 
с языком C++. </P><B>Структура программы</B> 
<P>Java-программа состоит из одного или нескольких определений классов, 
размещенных в одном или нескольких файлах (суффикс имени файла - .java). Для 
компиляции программ используется java-компилятор javac, например, <BR>javac 
FirstExample.java </P>
<P>В результате для каждого класса из исходного из исходного файла создается 
файл класса, содержащий байт-коды класса. Основа имени файла класса совпадает с 
именем класса, к ней добавляется суффикс .class. </P>
<P>Один из классов программы должен быть открытым (public) классом и содержать 
метод main, с которого начинается выполнение программы. </P>
<P>Для выполнения программы необходимо запустить интерпретатор java, указав ему 
имя класса, содержащего метод main, например,<BR>java FirstExample </P>
<P>Необходимо заметить, что апплет Java - это не приложение, а класс Java, 
который динамически загружается и выполняется внутри уже запущенного приложения, 
такого как appletviewer или web-броузер. </P>
<P>Java-программа завершает свою работу оператором return в методе main или 
после выполнения последнего оператора метода main. Однако, многопотоковая 
программа заканчивается с завершением последнего потока. </P><B>Прототип метода 
main</B> 
<P>Прототип функции main в C/C++ имеет следующий вид: 
<CENTER><PRE>int main (int argc, char* argv[], char* envp[]) ,
</PRE></CENTER>где argc - количество аргументов командной строки, argv - массив 
указателей на аргументы командной строки, envp - массив указателей на <I>среду 
выполнения</I> (множество пар "<I>имя</I>=<I>значение</I>"). 
<P></P>
<P>Метод main в Java имеет следующий прототип: 
<CENTER><PRE>public static void main (String argv[]) ,
</PRE></CENTER>где argv - это массив строк, представляющих собой аргументы 
командной строки вызова интерпретатора и располагающихся в ней после имени 
класса. Подчеркнем, что argv[0] в Java - это не имя класса, как мог бы ожидать 
программист С/С++, а действительно первый аргумент метода. 
<P></P>
<P>Приведенная ниже Java-программа реализует функцию команды echo из UNIX - 
выводит свои аргументы <PRE>public class echo {
  public static void main (String argv[]) {
    for (int i; i&lt;argv.length; i++)
      System.out.print (argv[i] + " ");
    System.out.print ("\n");
    System.exit (0);
    };
  }
</PRE>
<P></P>
<P>Необходить обратить внимание, что метод main не позволяет вернуть какой-либо 
код завершения с помощью оператора return (см. void в прототипе). При 
необходимости это можно сделать, вызвав метод System.exit (), как это показано в 
примере. Метод System.exit () немедленно и безусловно прекращает работу 
программы. </P>
<P>Из Java-программы (в отличие от C/C++-программ) переменные среды 
(environment), во многом определяемые ОС, недоступны. В качестве альтернативы в 
Java определен независимый от вычислителной платформы механизм, называемый 
<I>списком системных переменных</I> (system properties list). Для получения 
значения системной переменной используется метод System.getProperty(), например: 
<PRE>String homedir = System.getProperty("user.home");
String debug = System.getProperty("myapp.debug");
</PRE>
<P></P>
<P>Java-интерпретатор при запуске автоматически определяет ряд стандартных 
системных переменных. Пользователь имеет возможность дополнительно определить 
собственные системные переменные, используя опцию -D командной строки 
интерпретатора, например <PRE>java -Dmyapp.debug=true myapp
</PRE>
<P></P><B>Области видимости имен</B> 
<P>Являясь языком, поддерживающим динамическую загрузку методов через Internet, 
Java заботится о предотвращении конфликтов имен. Поэтому, в частности, в Java 
<I>нет глобальных переменных</I>, все переменные и функции (методы) - части 
класса, К тому же, каждый класс - часть пакета. 
<P>На каждую переменную или метод в Java ссылаются с помощью <I>полного</I> 
имени, состоящего из имени пакета, имени класса и имени члена класса, 
разделенных точкой. Имя пакета обычно состоит из многих составляющих, также 
разделенных точками. Разработчики Java для обеспечения уникальности имен пакетов 
в рамках Internet предлагают использовать в именах пакетов доменные имена 
организаций-разработчиков пакетов, например<BR><PRE>ru.bmstu.students.rk6.Ivanov.games
</PRE>
<P></P>
<P>Файлы классов хранятся в каталогах, определяемых именем пакета. Например, все 
игровые классы студента Иванова хранятся в каталоге с <I>относительным</I> 
именем <PRE>ru/bmstu/students/rk6/Ivanov/games
</PRE>
<P></P>
<P>Для определения <I>полного</I> путевого имени каталога, содержащего файлы 
классов пакета, Java-интепретатор java использует системную переменную 
CLASSPATH, устанавливать которую можно, например, в bash, командой <PRE>export CLASSPATH=.:~/classes:/usr/local/java/classes
</PRE>
<P></P>
<P>Пути к <I>системным</I> классам включать в CLASSPATH нет необходимости, так 
как интерпретатор Java эти пути присоединяет к списку справа самостоятельно. 
</P>
<P>Похожую, но не совсем аналогичную роль играет параметр -classpath 
интерпретатора java. </P>
<P>Для включения класса в пакет используется оператор <PRE>package <I>&lt;имя-пакета&gt;</I> ,
</PRE>который обязательно должен быть первым оператором исходного файла. Если 
оператор package отсутствует в исходном тексте класса, то класс считается 
принадлежашим пакету "по умолчанию", файлы классов которого размещаются в 
текущем каталоге, что удобно для разработки. 
<P></P>
<P>За необязательным оператором package может следовать любое количество 
операторов import, имеющих две формы записи: <PRE>import &lt;имя-пакета&gt;.&lt;имя-класса&gt;;
import &lt;имя-пакета&gt;.*;
</PRE>
<P></P>
<P>Назначение оператора import - дать возможность использования в тексте 
программ "укороченных" имен классов и их членов (без префиксной части в виде 
имени пакета). Важно понимать, что оператор import никакой загрузки отдельных 
классов или пакетов целиком за собой не влечет (в этом его отличие от #include в 
C и C++). Еще раз - классы в Java загружаются динамически только в момент 
возникновения потребности в них ! </P>
<P>Доступ к пакетам, классам и членам классов управляется использованием 
ключевых слов-модификаторов public (открытый), protected (защищенный) и private 
(закрытый) и регламентируется следующими правилами. <BR>
<UL>
  <LI>Пакет доступен, если доступны соответствующие файлы и каталоги (например, 
  если локальные файлы имеют соответствующие разрешения на чтение или могут быть 
  загружены по сети). 
  <LI>Каждый класс и интерфейс пакета доступен всем остальным классам и 
  интерфейсам того же пакета. Невозможно определить классы Java, видимые только 
  в одном файле с исходным текстом. 
  <LI>Класс, объявленный как public в одном пакете, доступен из другого пакета, 
  если доступен сам пакет. Классы, не объявленные как public, недоступны за 
  пределами данного пакета. 
  <LI>Члены класса доступны из другого класса того же пакета, если они не 
  объявлены как private. Члены класса, объявленные как private, доступны только 
  в своем классе. 
  <LI>Член класса A доступен из класса B, входящего в другой пакет, в тех 
  случаях, когда класс A, равно как и его член, объявлены как public или когда 
  класс A объявлен как public, член класса объявлен как protected, а класс B 
  является подклассом класса A. 
  <LI>Все члены класса всегда доступны внутри класса. </LI></UL>
<P></P><B>Комментарии</B> 
<P>В Java поддерживаются комментарии трех видов. 
<OL>
  <LI>В стиле языка C (от "/*" до "*/"). 
  <LI>В стиле языка C++ (от "//" до "\n"). 
  <LI>Специальные комментарии "для документирования" (от "/**" до "*/"), 
  используемые программой javadoc для создания простой интерактивной 
  документации из исходных файлов на языке Java. </LI></OL>
<P></P><B>Отсутствие препроцессора</B> 
<P>В Java отсутствует препроцессор, подобный препроцессору cpp в C/C++. А значит 
и нет #-директив таких, как #define, #include, #ifdef. Дело в том, что в Java 
нет необходимости в них . </P>
<P>Эквивалентом константы, объявленной в C/C++ через #define, служит переменная, 
объявленная в классе Java как static final, например java.lang.Math.PI. 
Преимущества такого подхода: строгая типизация констант и уникальность 
иерархических имен, что исключает конфликты (то же PI нельзя переопределить). 
</P>
<P>Макросы (другое использование #define) заменены inline-подстановкой, 
осуществляемой компилятором Java для "коротких" иетодов автоматически. </P>
<P>Ненужность #include объясняется двумя факторами. Во-первых, файл класса (с 
суффиксом .class) одновременно является и объявлением класса, и его определением 
(реализацией), значит, отпадает необходимость в загаловочных h-файлах. 
Во-вторых, стандартизованность в размещении файлов классов по каталогам дпет 
возможность интепретатору Java однозначно определять местоположение загружаемого 
класса, значит отпадает необходимость директивного включения файлов исходного 
текста. </P>
<P><I>Примечание.</I> К сожалению, отсутствие включения фрагментов исходного 
текста может сделать исходные файлы классов чрезмерно большими. Это особенно 
актуально в связи с тем, что Java допускает определение классов в классе, о чем 
речь ниже. </P>
<P>Условная компиляция (для нужны #ifdef/#endif в C/C++) в Java выполняется 
неявно. Дело в том, что нормальный Java-компилятор (например, javac) определяет 
участки исходного текста, которые никогда не будут выполняться, и игнорирует их, 
не генерируя для них байт-кода. Это значит, что конструкция C/C++ в виде <LISTING>#ifdef DEBUG
... отладочный код ...
#endif
</LISTING>может быть смоделированиа в Java конструкцией <LISTING>private static final boolean DEBUG = true/false;
if ( DEBUG ) {
  ... отладочный код ...
  };
</LISTING>
<P></P>
<P>Поскольку DEBUG - константа, компилятор еще до этапа интерпретации знает, 
будет код отладки когда-нибудь выполняться или нет. </P><B>Кодировка</B> 
<P>Символы, строки и идентификаторы (т.е. имена классов, переменных методов) в 
Java формируются 16-битовыми символами Unicode. Это обеспечивает, например, 
возможность давать классам и и их членам русские имена. </P>
<P><I>Примечание.</I> Представление в Unicode символов латинского алфавита 
совпадает с их представлением в ASCII и ISO8859-1 (Latin-1). </P>
<P>Но, к сожалению, Unicode включает в себя кодировку кириллицы совпадающую со 
стандартом ISO8859-5, не пользующимся у нас популярностью (хотя все UNIX-системы 
его поддерживают). </P>
<P>Для представления в исходных текстах Java символов, не имеющих графического 
представления (например, из-за отсутствия соответствующих шрифтов) используется 
следующая esc-последовательность \u<I>xxxx</I>, где <I>x</I> - шестнадцатиричная 
цифра. Например, \u044E представляет строчную русскую букву "ю". </P><B>Простые 
типы данных</B> 
<P>К списку простых типов данных C в Java добавлены byte и boolean. К тому же 
четко определены размер, знаковость, диапазон представления и значение "по 
умолчанию". Приведенная ниже таблица содержит эти характеристики для всех 
простых типов. </P>
<CENTER>
<TABLE border=1>
  <TBODY>
  <TR align=middle>
    <TH>Тип </TH>
    <TH>Содержимое </TH>
    <TH>Умолчание </TH>
    <TH>Размер </TH>
    <TH>Диапазон </TH></TR>
  <TR align=middle>
    <TD>boolean </TD>
    <TD>true/false </TD>
    <TD>false </TD>
    <TD>1 бит </TD>
    <TD>false ... true </TD></TR>
  <TR align=middle>
    <TD>char </TD>
    <TD>символ Unicode </TD>
    <TD>\u0000 </TD>
    <TD>16 битов </TD>
    <TD>\u0000 ... \uFFFF </TD></TR>
  <TR align=middle>
    <TD>byte </TD>
    <TD>целое со знаком </TD>
    <TD>0 </TD>
    <TD>8 битов </TD>
    <TD>-128 ... 127 </TD></TR>
  <TR align=middle>
    <TD>short </TD>
    <TD>целое со знаком </TD>
    <TD>0 </TD>
    <TD>16 битов </TD>
    <TD>-32768 ... 32767 </TD></TR>
  <TR align=middle>
    <TD>int </TD>
    <TD>целое со знаком </TD>
    <TD>0 </TD>
    <TD>32 бита </TD>
    <TD>-2147483648 ... 2147483647 </TD></TR>
  <TR align=middle>
    <TD>long </TD>
    <TD>целое со знаком </TD>
    <TD>0 </TD>
    <TD>64 бита </TD>
    <TD>-9223372036854775808 ... 9223372036854775807 </TD></TR>
  <TR align=middle>
    <TD>float </TD>
    <TD>числа с плавающей точкой в формате IEEE 754 </TD>
    <TD>0.0 </TD>
    <TD>32 бита </TD>
    <TD>+/-3.40282347E+38 ... +/-1.40239846E-45 </TD></TR>
  <TR align=middle>
    <TD>double </TD>
    <TD>числа с плавающей точкой в формате IEEE 754 </TD>
    <TD>0.0 </TD>
    <TD>64 бита </TD>
    <TD>+/-1.7976933486231570E+308 ... +/-4.94065645841246544E-324 
  </TD></TR></TBODY></TABLE></CENTER>
<P><I>Примечание.</I> Важно отметить, что исключив беззнаковые целые типы, 
разработчики Java впали в маразм (без всяких кавычек). Попробуйте быстренько 
вспомнить какое-либо отрицательное целое число из реального мира или представить 
в виде, удобном для оперирования им, IP-адрес 212.156.0.0. </P>
<P><B>Тип boolean.</B> Значения этого типа не являются целыми и не могут быть 
преобразованы из другого типа или в другой тип. Для "приведения" к целому и 
обратно можно использовать код, подобный приведенному ниже: <LISTING>boolean b;
int i;
i = (b) ? 1 : 0;	// из boolean в int
b = (i != 0);		// из int в boolean
</LISTING>
<P></P>
<P><B>Тип char.</B> Значения этого типа служат для представления символов в 
кодировке Unicode, Символьные литералы (как и в C/C++) заключаются в одинарные 
кавычки (апострофы), например, char c = 'A'; . </P>
<P>Поддерживаюся все esc-последовательности C и Unicode, например: <LISTING>char newline = '\n';
char apostrophe = '\'';
char delete = '\377';
char aleph = '\u05D0';
</LISTING>Тип char - <I>целый</I> тип, не имеющий знака, при преобразовании к 
типу byte или short результат может оказаться отрицательным. 
<P></P>
<P><B>Целые типы.</B> К ним в Java относятся byte, short, char, int, long. Из 
них беззнаковым является только char. Модификатора unsigned в Java нет. В 
остальном они полностью аналогичны целым типам языка C. </P>
<P>Арифметические операции над целыми числами деления на нуль или взятия остатка 
по основанию нуль генерируют исключение ArithmeticException. </P>
<P><B>Типы данных с плавающей точкой</B> включают в себя типы float и double. 
Литералы этих типов имеют тот же синтаксис, что и в языке C. </P>
<P>В работе с числами с плавающей точкой Java придерживается стандарта IEEE 754. 
При выполнении некорректных арифметических операций возможно получение особых 
значений: <I>плюс бесконечность</I>, <I>минус бесконечность</I>, <I>не 
число</I>, <I>минус нуль</I>. В классах java.lang.Float и java.lang.Double для 
некоторых из них определены символьные константы: POSITIVE_INFINITY, 
NEGATIVE_INFINITY, NaN. </P>
<P>Величина NaN - особенная, ее сравнение с другими величинами, включая ее саму, 
всегда дает false. Для проверки "на равенство" величине NaN используются методы 
Float.isNaN() и Double.isNaN(). </P>
<P><B>Строки</B> в Java <I>не</I> являются массивами символов, а являются 
объектами класса String. Однако, для представления строковых литералов в Java 
заимствован синтаксис языка C, например, <LISTING>String str = "Short string";
</LISTING>
<P></P><B>Ссылочные типы данных</B> 
<P>К не простым типам данных в Java относятся объекты и массивы. Эти типы часто 
называют <I>ссылочными</I>, поскольку доступ к ним осуществляется <I>по 
ссылке</I> (т.е. по адресу области памяти, занимаемой объектом или массивом). В 
то время как простые типы данных обрабатываются <I>по значению</I>. </P>
<P>Поясним разницу на следующем примере. При передаче некоторому методу целого 
числа типа byte (простой тип) в стек аргументов будет загружена <I>копия</I> 
значения этого числа. При передаче в качестве аргумента методу массива из всего 
лишь двух целых чисел типа byte в стек будет загружена <I>копия</I> адреса этого 
массива. </P>
<P>Еще один пример. Для объектов (ссылочный тип): <LISTING>Button p, q;
p = new Button;
q = p;
p.setLabel("QQ");
String s = q.getLabel();	// Теперь s содержит "QQ"
</LISTING>Для объектов простого типа: <LISTING>int i, j;
i = 1;
j = i;
i = 2;	// Здесь i = 2, а j = 1
</LISTING>
<P></P>
<P>И еще один пример. <LISTING>public void swap(Object a, Object b) {
  Object temp = a;
  a = b;
  b = temp;
  }
</LISTING>Можно предположить, что автор данного метода намеревался "поменять 
местами" (swap) два объекта класса Object, но ясно, что его усилия ушли впустую. 

<P></P>
<P><B>Копирование</B> данных ссылочного типа - не столь тривиальная задача, как 
копирование простых данных. Для копирования данных одного объекта в другой 
объект необходимо использовать метод clone(), например: <LISTING>Vector a, b;
a = new Vector;
b = a.clone();
</LISTING>После выполнения этого фрагмента b будет ссылаться на <I>дубликат</I> 
объекта a. Следует отметить, что метод clone() поддерживается только теми 
классами, которые реализуют <I>интерфейс</I> Cloneable (об интерфейсах позже). 
<P></P>
<P><B>Сравнение</B> данных ссылочного типа реализуется, конечно, не оператором 
"==", а методом equals(), реализованном в ряде классов (в C/C++ строки, 
например, тоже сравниваются не с помощью "==", а с помощью strcmp()). </P>
<P><B>Указатели</B> (pointers), еще раз подчеркнем, в Java отсутствуют и 
запрещены любые действия с адресами, а именно: 
<UL>
  <LI>преобразование ссылок в целое и обратно; 
  <LI>арифметика адресов (указателей); 
  <LI>вычисление размеров типов и объектов. </LI></UL>
<P></P>
<P><B>null</B> в Java - это зарезервированное ключевое слово, означающее 
<I>отсутствие ссылки</I>. Именно null является значением "по умолчанию" для всех 
ссылочных типов. Значение null нельзя привести к какому-либо простому типу, его 
нельзя считать равным 0 (как помним, в C/C++ NULL определен через #define как 
0). </P><B>Объекты</B> 
<P>Здесь очень кратко, подробно объекты описываются в следующем разделе. </P>
<P>Создание объекта осуществляется оператором new в точности так же, как в C++, 
например: <LISTING>ComplexNumber c = new ComplexNumber(1.0, 1.414);
</LISTING>
<P></P>
<P>Существует еще три способа создания объектов. Во-первых, исключительно для 
удобства пользователя создание объекта класса String может быть реализовано 
заключением текста строки в двойные кавычки, например: <LISTING>String s = "This is a string";
</LISTING>
<P></P>
<P>Во-вторых, для создания объекта можно использовать вызов метода newInstance() 
объекта класса Class. Этот способ используется при динамической загрузке 
классов. </P>
<P>В-третьих, объекты создаются путем их <I>десериализации</I>, т.е. путем их 
воссоздания из состояния хранения (например, на диске), в которое они были 
переведены путем <I>сериализации</I>. </P>
<P>Память для объектов в Java выделяется динамически, но операторов типа delete 
(C++) или методов типа free() (язык C) для явного освобождения ставшей ненужной 
памяти нет. </P>
<P>В Java для освобождения неиспользуемой памяти употребляется механизм 
автоматической <I>сборки мусора</I> (garbage collection), реализованный в виде 
низкоприоритетного потока. </P>
<P>Для доступа к членам классов и их экземпляров используется разделитель ".", 
например: <LISTING>ComplexNumber c = new ComplexNumber;
c.x =1.0;
c.y = 1.414;
double m = c.magnitude();
</LISTING>
<P></P><B>Массивы</B> 
<P>Практически все, что сказано выше про объекты, справедливо и для массивов: 
<UL>
  <LI>доступ к ним осуществляется по ссылкам; 
  <LI>создаются динамически с помощью new; 
  <LI>автоматически считаются мусором, если на них нет ссылки. </LI></UL>
<P></P>
<P>В Java существует два способа создания массивов. Первый выделяет память под 
массив и инициализирует его элементы значениями "по умолчанию", например: <LISTING>byte buff[] = new byte[1024];
Button bs[] = new Button[10];
</LISTING>В первой строке 1024 элементов массива buff заполняются нулями, во 
второй - 10 элементов массива bs заполняются значениями null. 
<P></P>
<P>Второй способ не только выделяет память, но и сразу же инициализирует ее 
указанными значениями, например: <LISTING>int table[] = {1, 2, 4, 8, 16, 32, 64, 128};
</LISTING>Кстати, Java допускает и новый (относительно C/C++) синтаксис 
объявления массивов, как это показано ниже: <LISTING>int[] table = {1, 2, 4, 8, 16, 32, 64, 128};
</LISTING>
<P></P>
<P>Доступ к элементам массива осуществляется так же, как и в C - индекс в виде 
целого выражения в квадратных скобках. При попытке обратиться за пределы массива 
генерируется исключение ArrayIndexOutOfBoundsException. </P>
<P><I>Примечание</I>. Попытайтесь придумать код для такой проверки, 
запрограммируйте его, например, на языке C, взгляните на ассемблерный листинг и 
сравните с кодом доступа к элементу массива на языке C (можно предполагать, что 
это будет единственная машинная команда загрузки "ячейки" памяти в регистр 
общего назначения). Пофантазируем: для такой проверки используется "железо". 
Тогда, во-первых, Java-машина должна запускаться, как минимум, с привилегиями 
root. Во-вторых, аппаратные средства контроля доступа имеют градацию в виде 
"страницы" памяти (типично, 512 байт). </P>
<P>Для определения длины массива используется переменная экземпляра length, 
определенная как константа (final). </P><B>Строки</B> 
<P>В Java строки не являются массивами символов, заканчивающимися символом NULL. 
Напротив, строки - это экземпляры класса java.lang.String. Но специально для 
этого класса в Java реализован оператор "+", осуществляющий конкатенацию строк. 
</P>
<P>Важной особенностью объектов String является их неизменяемость, т.е. в классе 
String методов, модифицирующих содержимое строки нет. Если необходима 
модификация, то из объекта String следует создать объект StringBuffer. Наиболее 
важные методы класса String - length(), charAt(), equals(), compareTo(), 
indexOf(), lastIndexOf(), substring(). </P><B>Операторы</B> 
<P>В Java поддерживаются почти все операторы C (с теми же правилами приоритета и 
ассоциативности). Исключены операторы работы с указателями (*, -&gt;, &amp;), 
оператор sizeof, а конструкции "[]" (доступ к массиву) и "." (доступ к члену) 
операторами не считаются. </P>
<P>В Java добавлены следующие новые операторы.<BR>instanceof<BR>Возвращает 
значение true, если объект, стоящий слева, принадлежит классу/подклассу или 
реализует интерфейс, стоящий справа.<BR>&gt;&gt;&gt;<BR>Выполняет побитовый 
сдвиг вправо, устанавливая старшие биты результата в 0.<BR>+<BR>Выполняет 
конкатенацию строк.<BR>&amp; и |<BR>Для типа boolean выполняет логические 
операции И и ИЛИ.<BR></P><B>Управляющие конструкции</B> 
<P>Java повторяет большинство управляющих конструкций языка C (исключая goto), 
добавляя две новые: try/catch/finally и synchronized. Кроме того в операторах 
break и continue обеспечена возможность перехода по метке. </P>
<P>Оператор <B>break</B> без метки работает точно так же, как и в C: он 
прерывает выполнение тела того цикла for, while, do или конструкции switch, 
внутри которого/ой он размещен. Оператор break с меткой завершает выполнение 
внешнего блока, помеченного меткой, при этом автоматически выполняются все блоки 
finally, если они определены (об операторе try, в состав которого входит блок 
finally ниже). Например. <LISTING>test: if ( check(i) ) {
  try {
    for (int j=0; j<10; j++) {
      if (j>i) break;	// Завершение цикла for
      if (a[i][j] == null)
        break test;	// Выполнение оператора finally
      };		// и завершение if
    }
   finally {
     cleanup (a, i,j);
     };
  }
</LISTING>
<P></P>
<P>Оператор <B>continue</B> с меткой передает управление на конец помеченного 
внешнего цикла for, while или do. Если между оператором continue и концом 
соответствующего цикла находится блок finally, то он автоматически выполняется 
до перехода к концу цикла. Например. <LISTING>big_loop: while (!done ) {
  if ( test(a,b)==0 ) continue;	// Переход в точку 2
  try {
    for (int i=0; i<10; i++) {
      if (a[i] == null) {
        continue;	// Переход в точку 1
	}
       else {
         if (b[i] == null)
	   continue big_loop;	// Переход в точку 2 после выполнения блока finally
	 };
      };
    // Точка 1. Приращение счетчика i и переход в начало цикла
    }
   finally {
    cleanup (a, b);
    // Точка 2. 
    };
  }
</LISTING>
<P></P>
<P>Конструкция <B>synchronized</B> используется в многопоточных программах для 
предоставления отдельному потоку исключительного доступа к объекту или массиву. 
Она имеет следующий синтаксис: 
<CENTER><PRE>synchronized (<I>выражение</I>) {<I>блок-операторов</I>}
</PRE></CENTER>, где <I>выражение</I> представляет собой объект или массив. 
<I>Блок-операторов</I> будет запущен на выполнение только тогда, когда 
synchronized убедится, что <I>выражение</I> не используется другими потоками 
управления. На время исполнения <I>блок-операторов</I> доступ к объекту или 
массиву блокируется. 
<P></P>
<P>В Java ключевое слово synchronized часто используется как спецификатор 
доступа к методу. Если метод объявлен как synchronized, то он получает 
исключительный доступ к своему классу или экземпляру класса. </P><B>Исключения и 
их обработка</B> 
<P>Исключения - важная особенность Java, отличающая ее от C (но не C++). </P>
<P><I>Исключение</I> (exception) - сигнал, свидетельствующий о возникновении 
нештатной ситуации (например, ошибки). Исключения могут <I>генерироваться</I> 
или <I>выдаваться</I> (throw) как системными классами Java, так и классами 
пользователей. <I>Перехвать</I> (catch) исключение - значит обработать его, 
попытавшись восстановить нормальную работу программы. </P>
<P>Исключения распространяются вверх (обратно) по всей цепочке вызовов методов и 
включений блоков кода. Если исключение не перехвачено сгенерировавшим его 
блоком, то оно передается в охватывающий блок. Если исключение вообще не 
перехвачено в текущем методе, то оно передается для обработки в вызывающий 
метод. И так далее вплоть до головного метода main, что заставляет интерпретатор 
Java выдать сообщение об ошибке. </P>
<P>Исключения в Java - это объекты, являющиеся экземплярами подклассов класса 
java.lang.Throwable. Из Throwable порождены 2 стандартных подкласса: 
java.lang.Error и java.lang.Exception. Исключения, являющиеся подклассом класса 
Error, сигнализируют, главным образом, об неустранимых проблемах (нехватка 
памяти, ошибки динамической загрузки и т.п.), поэтому они перехватываться не 
должны. Исключения же, являющиеся подклассами Exception, свидетельствуют о 
ситуациях, которые можно корректно обработать, Например, java.io.EOFException 
говорит о достижении конца файла, а java.lang.ArrayAccessOutOfBounds - о попытке 
доступа к элементу, находящемуся за пределами массива. </P>
<P>Т.к. исключения - это объекты, то они могут содержать в себе данные и методы. 
Класс Throwable включает в себя строку строку сообщения типа String, прочитать 
ее можно с помощью метода Throwable.getMessage(). Тело сообщения задается при 
создании объета исключения путем передачи аргумента конструктору. Некоторые 
исключения добавляют и другие данные в свой класс. </P>
<P><B>Обработка исключений</B> в Java реализуется с помощью конструкции 
try/catch/finally, имеющей следующий общий вид: <LISTING>try {
  // Блок кода, в котором могут присутствовать 
  // операторы break, continue и return,
  // и который может генерировать исключения 
    }
 catch (SomeException e1) {
  // Обработка исключения e1 типа SomeException
  // или подкласса этого типа
  }
 catch (AnotherException e2) {
  // Обработка исключения e2 типа AnotherException
  // или его подкласса 
  }
 finally {
  // Этот код всегда выполняется после кода в  try независимо от условия выхода
  }
</LISTING>Внутри блока <B>try</B> содержится код, в ходе выполнения которого 
могут возникать исключения или неустранимые ошибки. Внутри блока могут 
содержаться операторы передачи управления break, continue и return. 
<P></P>
<P>После блока try может следовать любое (в том числе и нулевое) количество 
блоков <B>catch</B>, в которых содержится код обработки исключений различных 
типов. При возникновении исключения в блоке try его выполнение прерывается. 
Далее последовательно просматриваются блоки catch и управление передается тому 
блоку, чей тип аргумента совпадает с классом объекта исключения или является его 
суперклассом. Аргумент блока catch действителен только внутри своего блока и 
ссылается на сгенерированный в блоке try объект исключения. </P>
<P>Блок <B>finally</B> содержит код, который безусловно вызывается на 
выполнение, если выполнялась хотя бы минимальная часть блока try. Конкретнее. 
<UL>
  <LI>Если выход из блока try осуществляется оператором break, continue (с 
  меткой или без) или return, код блока finally выполняется прежде, чем 
  управление будет передано в другую точку программы. 
  <LI>Если в блоке try генерируется исключение, и при этом существует 
  соответствующий локальный блок catch, управление сначала переходит к коду 
  этого блока, а затем - к коду блока finally. 
  <LI>Когда необходимый блок catch отсутствует, управление передается к блоку 
  finally, а от него - к ближайшему <I>охватывающему</I> блоку catch, который 
  ориентирован на обработку данного исключения. </LI></UL>
<P></P>
<P>Отметим, что, если код блока finally сам передает управление посредством 
return, break или continue или посредством генерации нового исключения, то 
отложенная передача управления отменяется и реализуется эта новая передача. </P>
<P>Блок finally обычно используется для корректного завершения блока try 
(освобождение ресурсов, закрытие файлов и т.п.). </P>
<P>В Java каждый метод, способный генерировать исключения, но не перехватывающий 
их, должен известить об этом мир, используя конструкцию throws в объявлении 
метода, например: <LISTING>public void myfunc (int arg) throws MyExcept1, MyExcept2 {
  <I>код, генерирующий исключения MyExcept1 и MyExcept2</I>
  }
</LISTING>
<P></P>
<P>Заметим, если метод генерирует какое-либо исключение, но перехватывает и 
обрабатывает его самостоятельно, то упоминание этого исключения в конструкции 
throws смысла не имеет. </P>
<P>Также излишне перечислять в throws исключения, являющиеся подклассами классов 
Error и RuntimeException (например, исключение InternalError), поскольку они 
присутствуют там неявно. Дело в том, что такие исключения способен генерировать 
<I>каждый</I> метод. </P>
<P>Класс исключения, определенного в throws, может быть суперклассом всех тех 
исключений, которые действительно могут быть порождены методом. </P>
<P>Стандартные исключения, которые часто приходится объявлять - 
java.lang.io.IOException и java.lang.InterruptedException. </P>
<P>Для <B>генерации</B> исключений в программе на Java используется оператор 
throw, вслед за которым следует объект класса Throwable. Часто объекты 
исключений создаются в том же операторе, в котором они порождаются, например: <LISTING>throw new MyExcept("My exception occured.");
</LISTING>
<P></P><B>Прочие отличия от C</B> 
<P>
<UL>
  <LI>Java допускает локальные объявления переменных в месте их использования (с 
  большими ограничениями, чем в C++). 
  <LI>В Java отсутствует struct, т.к. класс с открытыми переменными и без 
  методов - это структура C. 
  <LI>В Java нет union, т.к. union можно смоделировать подклассами. 
  <LI>В Java отказались от enum, а жалко. 
  <LI>В Java нет битовых полей, но их можно смоделировать масками. 
  <LI>В Java, как объектно-ориентированном языке, необходимости в typedef просто 
  нет. 
  <LI>В Java недопустимы методы с переменным числом аргументов, поскольку Java - 
  строго типизированный язык. Перегрузка методов, пусть не полностью, но 
  позволяет обойти это ограничение. 
  <LI>В Java отсутствует тип метода (в C/C++ допустимы указатели на методы), а 
  это значит, что метод нельзя передать другому методу в качестве аргумента, 
  например, для организации <I>callback</I>-обработки. Приходится создавать 
  класс, содержащий нужный метод, и передавать в качестве аргумента объект 
  данного класса. 
  <LI>В Java добавлен ряд модификаторов, которые можно применять при объявлении 
  переменных и/или методов для наложения ограничений или предоставления 
  дополнительной информации. 
  <DL>
    <DT>final 
    <DD>Этот модификатор может применяться к классам, методам и переменным. 
    Класс, объявленный как final, не может иметь подклассов, а финальный метод 
    не может быть переопределен. Переменной, объявленной как final, нельзя 
    присвоить новое значение. 
    <DT>native 
    <DD>Этот модификатор можно использовать при объявлении методов. Он 
    показывает, что данный метод уже реализован где-либо зависящим от 
    вычислительной платформы способом (например, на языке C). Метод, объявленный 
    как native, должен содержать точку с запятой в качестве своего тела. 
    <DT>synchronized 
    <DD>Этот модификатор можно использовать при объявлении методов класса и 
    методов экземпляра класса. Он сигнализирует о том, что соответствующий метод 
    неатомарно изменяет состояние класса или объекта. Поэтому Java должна 
    обеспечивать блокирование класса или объекта на время выполнения 
    synchronized-метода от доступа из других потоков управления. 
    <DT>transient 
    <DD>Этот модификатор может применяться к переменным экземпляра класса. 
    Указывает, что переменная не является частью устойчивого состояния объекта, 
    поэтому нет необходимости в ее сериализации вместе с объектом. 
    <DT>volatile 
    <DD>Этот модификатор может применяться к переменным. Указывает, что 
    переменная используется асихронными потоками управления, поэтому для нее не 
    должна выполняться оптимизация кода. </DD></DL></LI></UL>
<P></P>
<CENTER>
<H2><A name=diff_c++>Классы и объекты в Java (отличия от C++)</A> 
</H2></CENTER><B>Пример</B><BR>Ниже приведен пример текста на Java, описывающего 
(частично) класс Circle - класс окружностей. <LISTING>public class Circle {
  // Переменные экземпляров
  public double x, y;	// Координаты центра
  public double r;	// Радиус
  // Конструкторы
  public Circle (double x, double y, double r) {
    this.x = x; this.y = y; this.r = r;
    };
  public Circle (double r) {
    this(0.0, 0.0, r);	// Вызывает трехаргументный конструктор
    };
  public Circle () { this(0.0, 0.0, 1.0); };
  // Методы экземпляров класса (объектов)
  public double circumference () {
    return 2*3.14159*r;
    };
  public double area () {
    return 3.14159*r*r;
    };
  }
</LISTING>Обратите внимание, в Java <I>объявление</I>класса и его 
<I>определение</I> даются в одном месте (представляют собой единое целое). 
<P>Создание экземпляра класса (объекта класса) обычно реализуется с помощью 
оператора new, как это показано ниже. <LISTING>Circle c;
c = new Circle();
или
Circle c = new Circle();
</LISTING>
<P></P>
<P>Доступ к открытым (public) членам класса осуществляется через ".": <LISTING>Circle c = new Circle();
c.x = 2.0; c.y =2.0; c.r = 1.0;
double a = c.area();	// Но не area(c)!
</LISTING>
<P></P><B>Конструкторы </B><BR>
<P>В примерах выше объект класса Circle создавался путем вызова 
<I>конструктора</I> "по умолчанию" Circle() без аргументов. Таким конструктором 
автоматически снабжается каждый вновь создаваемый класс в Java (хотя его можно и 
переопределить). Задача конструктора "по умолчанию" состоит в выделении памяти 
под переменные объекта и инициализации их значениями "по умолчанию". </P>
<P>В примере, описывающем класс Circle, определен еще один конструктор с тремя 
аргументами. Он не только выделяет память под объекты класса Circle, но и 
инициализирует значения их переменных своими аргументами. Обратите внимание на 
необходимость использования в этом конструкторе указателя this для исключения 
конфликта имен. This в Java (как и в C++) является <I>указателем на это</I> 
(this pointer), т.е. на текущий объект. </P>
<P>В Java допустимо задавать для класса любое количество конструкторов. Надо 
только помнить, что имя конструктора совпадает с именем класса, в объявлении 
конструктора не указывается тип возвращаемого значения или ключевое слово void, 
т.к. конструктор всегда в неявном виде возвращает this. </P><B>Перегрузка 
методов </B><BR>
<P>Как показывает пример с несколькими конструкторами Java допускает наличие у 
класса методов с одинаковыми именами, но разными типами аргументов, что 
называется <I>перегрузкой методов</I> (method overloading). В Java любые два 
метода воспринимаются как различные, если у них не совпадает хотя бы один из 
следующих признаков: имя, количество аргументов, попарно типы аргументов. Тип 
возвращаемого значения в этот список не входит (а как там в C++?). 
</P><B>Переменные класса </B><BR>
<P>Это (как и в C++) переменные, существующие в единственной копии для всего 
класса независимо от количества созданных объектов (экземпляров) данного класса. 
В этом их отличие от переменных экземпляров, которые создаются для каждого 
объекта. </P>
<P>Переменные класса в Java маркируются модификатором static, как это показано 
ниже: <LISTING>public class Circle {
  static int num_circles = 0;
  public static final double PI = 3.14159265358979323846;
  // далее известный код
  }
</LISTING>
<P></P>
<P>Переменная num_circles может быть использована для подсчета количества 
созданных объектипов типа Circle, для этого каждый конструктор объекта класса 
Circle должен увеличивать значение этой переменной на 1 (понятно, что 
конструктор "по умолчанию" в этом случае должен быть обязательно перегружен). 
</P>
<P>Переменная PI, тоже принадлежащая классу, а не к экземпляру, на самом деле 
переменной не является. Она - константа, о чём говорит модификатор final в её 
объявлении. </P>
<P>Для доступа к переменным класса используется не имя объекта, а, естественно, 
имя класса, например: <LISTING>  System.out.println ("Num = " + Circle.num_circles);
  Circle.PI = 3.62;
  double circumference = 2*Circle.PI*radius;
</LISTING>Заметим, что попытка изменить константу PI во второй строке вызовет 
ошибку на этапе компиляции. Кроме того, компилятор Java достаточно 
интеллектуален для того, чтобы произведение двух констант 2*Circle.PI превратить 
в одну. 
<P></P>
<P>Переменные класса инициализируются при первой загрузке класса, тогда как 
переменные экземпляра - при создании объекта. При необходимости сложной 
инициализации переменных класса в определение класса включается конструкция 
следующего вида: 
<CENTER><PRE>static { <I>код инициализации</I> };
</PRE></CENTER>
<P></P><B>Методы класса </B><BR>
<P>Методы класса не связаны с конкретными объектами класса и поэтому в них 
недопустимо использование "указателя на это" this ("этого" для них просто не 
существует). Расширим класс Circle следующими двумя методами: <LISTING>public Circle bigger (Circle c) {	// Метод экземпляра
  if (c.r > r) return c; else return this;
  };
public static Circle bigger (Circle a, Circle b) {	// Метод класса
  if (a.r > b.r) return a; else return b;
  };
</LISTING>
<P></P>
<P>Использование этих методов иллюстрирует следующий пример: <LISTING>  Circle a = new Circle(2.0);
  Circle b = new Circle(3.0);
  Circle c;
  c = a.bigger(b);	// или c = b.bigger(a);
  c = Circle.bigger(a, b);
</LISTING>
<P></P>
<P>Легко видеть, что методы классов - это аналог функций языков C/C++ (нет this 
- нет никаких объектов). Хотя Java - объектно-ориентированный язык, оказалось, 
что без функций в духе C в нем не обойтись, т.к. существуют простые типы данных, 
не являющиеся объектами (например, double). А для простых типов данных тоже 
нужны функции. Так, класс Math - это набор метод класса (математических функций) 
для оперирования с числами с плавающей точкой. Другой класс, где определены 
только методы класса - это System. </P><B>Уничтожение объекта </B><BR>
<P>В Java нет средств явного удаления созданных объектов (конструкции типа 
free() или delete отсутствуют). Как уже говорилось, объекты уничтожаются 
<I>сборщиком мусора</I> (garbage collector). </P>
<P>Сборщик, функционируя в рамках низкоприоритетного потока управления, 
отыскивает и удаляет объекты, на которые нет ссылки из других объектов и 
переменных. Более того, он способен обнаружить изолированные группы объектов с 
перекрестными ссылками друг на друга, но на которые нет ссылке извне. Однако, 
надо понимать, что проповедуемая Java технология "создал объект, попользовался и 
бросил" работает удовлетворительно не всегда. Например, вполне можно представить 
себе такой (пусть не очень грамотный) метод: создается массив matrix большого 
размера (например, квадратной матрицы), он перерабатывается в другой массив 
(например, в обратную матрицу или вектор собственных значений), далее следует 
длительная обработка, касающаяся только второго массива. Ясно, что все время 
длительной обработки уже ненужный исходный массив matrix будет непродуктивно 
занимать большой объем памяти. Выход в такой ситуации - это явно дать знать 
сборщику мусора о том, что объект стал ненужным, выполнив в соответствующем 
месте оператор <LISTING>matrix = null;
</LISTING>
<P></P>
<P>Перед удалением объекта сборщик мусора вызывает на выполнение метод 
finalize(), если он определен в классе бъекта. Этот метод <I>завершения</I> 
(аналог деструктора в C++) представляет собой метод экземпляра (не static), не 
имеет аргументов и не возвращает значения (void). </P>
<P>Вот что еще необходимо знать о методах завершения Стр. 85 </P><B>Подклассы и 
наследование </B><BR>
<P>Для определения подкласса некоторого класса в Java используется ключевое 
слово extends (расширяет), как это показано ниже: <LISTING>public class GraphicCircle extends Circle {
  Color outline, fill;
  public void draw (DrawWindow dw) {
    dw.drawCircle (x, y, r, outline, fill);
    };
  }
</LISTING>
<P></P>
<P>Каждый подкласс <I>наследует</I> все переменные и методы своего родителя - 
<I>суперкласса</I>. Поэтому представленный ниже оператор вполне корретен <LISTING>  GraphicCircle gc = new GraphicCircle(-2.0, 2.0, 3.0);
  double area = gc.area();
</LISTING>
<P></P>
<P>Кроме того, важно, что каждый объект подкласса является и полноправным 
объектом суперкласса, например: <LISTING>  Circle c = gc;
</LISTING>Однако, теперь через c доступ к графическим возможностям наследующего 
класса GraphicCircle стал невозможен. 
<P></P>
<P><B>Финальные классы</B> - это классы, объявленные с модификатором final. Для 
таких классов запрещено определять подклассы. Объявление классов как 
нерасширяемых позволяет компилятору Java выполнять некоторую оптимизацию вызовов 
его методов. </P>
<P>У любого класса есть суперкласс. Если он не указан явно в конструкции 
extends, то родителем класса считается класс Object, возглавляющий всю иерархию 
объектов Java (только класс Object не имеет родителя). </P>
<P><B>Конструктор подкласса</B> для вызова конструктора своего суперкласса может 
использовать конструкцию super(). Например, конструктор для класса GraphicCircle 
может иметь следующий вид: <LISTING>  public GraphicCircle (double x, double y, double r, Color outline, Color fill) {
    super (x, y, r);
    this.outline = outline;
    this.fill = fill;
    };
</LISTING>
<P></P>
<P>Ограничения на использование super() таковы: 
<UL>
  <LI>конструкцию super() можно использовать только в теле конструктора; 
  <LI>вызов конструктора суперкласса должен быть <I>самым первым</I> оператором 
  тела конструктора (он должен предшествовать даже объявлениям переменных). 
</LI></UL>
<P></P>
<P>Если в конструкторе подкласса отсутствует явный вызов конструктора 
суперкласса, то Java вставляет в самое его начало вызов super() неявно. Если в 
суперклассе отсутствует конструктор без аргументов, то возникает ошибка 
компиляции. Таким образом при создании объекта любого класса в Java 
последовательно вызывается цепочка конструкторов, начинающаяся с конструктора 
головного класса Object. </P>
<P>Если при создании объекта Java выстраивает обязательную цепочку вызовов 
конструкторов "сверху вниз", то можно было бы ожидать, что при удалении объектов 
она заставит организовать цепочку методов завершения finalize() "снизу вверх". 
Но это не так: вызывать или нет метод завершения суперкласса из метода 
завершения подкласса - желание программиста. </P><B>Переопределение методов 
</B><BR>
<P>Метод подкласса <I>переопределяет</I> (override) метод суперкласса, если он 
имеет те же имя, количество аргументов, тип и порядок расположения аргументов, а 
также тип возвращаемого значения. Необходимо четко понимать, что переопределение 
(override) метода - это не его перегрузка (overload). Для вызова из метода 
подкласса переопределенного метода суперкласса в Java используется префикс 
"super.". Например, класс A определяет метод int func(int), его подкласс B 
переопределяет этот метод, тогда, если где-то в методах класса B необходимо 
вызвать метод func() класса A, то необходимо использовать оператор <LISTING>  int i = super.func(25);
</LISTING>Однако конструкция super.super.func() для вызова метода func() не 
отца, а деда, недопустима! 
<P></P>
<P>Конструкция "super." часто используется в методах завершения (помним, что их 
имя фиксировано - finalize). Если из метода завершения подкласса необходимо 
вызвать метод завершения суперкласса, то используется оператор <LISTING>  super.finalize();
</LISTING>в качестве последнего оператора метода завершения. 
<P></P>
<P>Метод некоторого класса называется <I>финальным</I>, если он объявлен с 
модификатором final. Такой метод невозможно переопределить ни в одном подклассе 
данного класса. Имея дело с финальным методом, компилятор Java получает 
возможность оптимизировать его вызов. </P><B>Динамический вызов методов </B><BR>
<P>Пусть есть класс A, определяющий метод f(), два его подкласса B и C 
переопределяют этот метод (каждый по своему). Создается вектор v элементов типа 
A, который заполняется вперемежку объектами классов A, B и C. Далее 
осуществляется вызов v[i].f(). Метод f() какого класса будет вызван на 
выполнение? Понятно, что компилятор Java заранее знать конкретный класс объекта, 
который попадет в i-ый элемент вектора на этапе выполнения знать не может. 
Поэтому он генерирует байт-код <I>динамического</I> поиска необходимого метода и 
его вызова. Такой поиск, естественно, замедляет вызов метода. </P>
<P>К счастью, во многих случаях компилятор Java имеет возможность создавать 
байт-код непосредственного вызова метода, руководствуясь модификаторами static, 
private и final в описании методов и классов. Кроме того, методы, вызываемые 
непосредственно, являются кандидатами на inline-подстановку (если, конечно, их 
размер невелик). </P><B>Модификаторы видимости </B><BR>
<P>В Java используются 4 типа ограничений на доступ к членам класса. Три из них 
задаются модификаторами public (открытый), protected (защищенный) и private 
(закрытый). Четвертый тип - "по умолчанию", действующий при отсутствии в 
объявлении члена какого-либо из этих модификаторов. </P>
<P>Представленная ниже таблица описывает правила доступа к членам класса. 
<CENTER>
<TABLE border=1>
  <TBODY>
  <TR>
    <TH rowSpan=2>Доступен для</TH>
    <TH colSpan=4>Тип доступа</TH></TR>
  <TR align=middle>
    <TH>public</TH>
    <TH>protected</TH>
    <TH>по умолчанию</TH>
    <TH>private</TH></TR>
  <TR align=middle>
    <TD>Того же класса</TD>
    <TD>да</TD>
    <TD>да</TD>
    <TD>да</TD>
    <TD>да</TD></TR>
  <TR align=middle>
    <TD>Класса из того же пакета</TD>
    <TD>да</TD>
    <TD>да</TD>
    <TD>да</TD>
    <TD>нет</TD></TR>
  <TR align=middle>
    <TD>Подклассов из того же пакета</TD>
    <TD>да</TD>
    <TD>да</TD>
    <TD>нет</TD>
    <TD>нет</TD>
  <TR align=middle>
    <TD>Подклассов из других пакетов</TD>
    <TD>да</TD>
    <TD>нет</TD>
    <TD>нет</TD>
    <TD>нет</TD></TR></TR></TBODY></TABLE></CENTER>
<P></P>
<P>Могут быть даны следующие рекомендации по использованию модификаторов 
доступа. 
<UL>
  <LI>Применяйте модификатор public для тех методов и констант, которые входят в 
  состав открытого API класса. Некоторые очень важные или часто используемые 
  переменные могут также использоваться как public, но общепринятым является 
  объявлять переменные как не-public и инкапсулировать их в public-методах. 
  <LI>Применяйте модификатор protected для переменных и методов, которые не 
  обязательно используются в данном классе, но могут понадобиться при создании 
  подкласса, входящего в другой пакет. 
  <LI>Используйте тип видимости по умолчанию для переменных и методов, которые 
  не должны быть видны вне пакета, но к которым желательно иметь доступ из 
  классов того же пакета, взаимодействующих с данным классом. 
  <LI>Применяйте модификатор private для переменных и методов, которые 
  используются только внутри данного класса и должны быть скрыты для остальных. 
  </LI></UL>
<P></P><B>Абстрактные классы </B><BR>
<P>Java позволяет определять метод без его реализации, отмечая его как abstract. 
Вместо тела таких методов указывается ";" (точка с запятой). Ниже даны правила 
для <I>абстрактных методов</I> и содержащих их <I>абстрактных классов</I>. 
<UL>
  <LI>Любой класс, включающий абстрактный метод, автоматически становится 
  абстрактным классом. Абстактный класс должен содержать хотя бы один 
  абстрактный метод. 
  <LI>Класс может быть объявлен abstract даже в том случае, когда он не содержит 
  ни одного абстактного метода. Этим гарантируется невозможность создания 
  экземпляров такого класса. 
  <LI>Абстактный класс не может иметь экземпляров. 
  <LI>Подкласс абстрактного класса может иметь экземпляры, если в нем 
  переопределяются все абстрактные методы его суперкласса, и обеспечивается 
  реализация для каждого из них. 
  <LI>Если подкласс абстрактного класса не реализует все унаследованные 
  абстактные методы, он сам становится абстактным. </LI></UL>
<P></P>
<P>Предположим, что планируется создать ряд классов геометрических фигур: 
Circle, Ellipse, Rectangle, Triangle и т.п. Для каждого из них необходимо 
реализовать два общих метода: area() (площадь) и circumference() (периметр). Для 
обеспечения возможности работы с массивом фигур полезно иметь для всех этих 
классов суперкласс Shape с методами area() и circumference(). Однако реализовать 
эти методы в Shape невозможно. В этом случае Shape должен объявить эти методы 
абстрактными (и автоматически стать абстрактным классом). <LISTING>public class Shape {
  public abstract double area();
  public abstract double circumference();
  }
</LISTING>
<P></P>
<P>Подчеркнем два важных момента. 
<UL>
  <LI>Объекты любого подкласса класса Shape могут быть присвоены любому элементу 
  любого массива типа Shape. В приведении типа необходимости нет. 
  <LI>Методы area() и circumference() можно вызывать для объектов типа Shape, 
  синтаксической ошибки здесь нет. </LI></UL>
<P></P><B>Интерфейсы </B><BR>
<P><I>Интерфейс</I> похож на абстрактный класс, за исключением того, что все 
методы интерфейса <I>неявно</I> определены абстрактными, например: <LISTING>public interface Drawable {
  public void setColor (Color c);
  public void setPosition (double x, double y);
  public void draw (DrawWindow dw);
  }
</LISTING>
<P></P>
<P>Если в состав интерфейса входит переменная, то она обязательно должна быть 
объявлена как static final (т.е. быть константой). </P>
<P>Интерфейсы введены в Java для обеспечения некоторого подобия множественного 
наследования, которое в своем чистом виде в Java не поддерживается. Любой класс 
Java может реализовывать (implement) любое количество интерфейсов. <LISTING>public class DrawableCircle extends Circle implements Drawable {
  private Color c;
  // Конструктор
  public DrawableCircle (double x, double y, double r) { super(x, y, r); };
  // Методы интерфейса Drawable
  public void setColor (Color c) { this.c = c; };
  public void setPosition (double x, double y) { this.x = x; this.y = y; };
  public void draw (DrawWindow dw) { dw.drawCircle(x, y, r, c); };
  }
</LISTING>
<P></P>
<P>Интерфейсы в Java являются таки же типами данных, как и классы. Если класс 
реализует какой-либо интерфейс, то экземпляры этого класса могут быть присвоены 
переменным, имеющим тип реализуемого интерфейса. </P>
<P>Интерфейсы, являясь особым видом классов, могут расширяться подинтерфейсами. 
При этом подинтерфейс может наследовать сразу несколько суперинтерфейсов. </P>
<P>В Java имеет смысл определять и использовать пустые <I>интерфейсы-метки</I>, 
не объявляющие ни одного метода. Смысл использования таких интерфейсов - 
сгруппировать на основе какого-либо свойства несколько классов. Примером 
интерфейса-метки служит интерфейс Clonable из пакета java.lang, он позволяет 
идентифицировать класс, для которого существует метод clone() класса Object, 
позволяющий получить копию объекта. Проверить, реализует ли некоторый класс 
какой-либо интерфейс (в том числе интерфейс-метку) позволяет оператор 
instanceof. </P></BODY></HTML>
